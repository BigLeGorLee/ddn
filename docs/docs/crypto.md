## 概要

加密、解密和签名等工作，主要由 `@ddn/crypto` 完成，我们将所有有关加解密相关的操作都进行了整理，统一通过该库来完成，这样的好处非常明显，扩展方便、使用简单，也让原来的代码简化了很多。

## 编码及加密

Base58加密原理：和通常base64编码一样，base58编码的作用也是将非可视字符可视化（ASCII化）。但不同的是base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)。

参考：[bs58.js](../packages/crypto/src/base58check/bs58.js)

## 生成地址(公钥)

1. 获取一个随机的32字节ECDSA密钥

私钥：
2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b5d036a858ce89f844491762eb89e2bfbd50a4a0a0da658e4b2628b25b117ae09

ECDSA，就是椭圆曲线数字签名算法，是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟，即：ECC与DSA的结合，整个签名过程与DSA类似，所不一样的是签名中采取的算法为ECC，最后签名出来的值也是分为r,s。ECDSA于1999年成为ANSI标准，并于2000年成为IEEE和NIST标准。

签名过程如下：
1、选择一条椭圆曲线Ep(a,b)，和基点G；
2、选择私有密钥k（k<n，n为G的阶），利用基点G计算公开密钥K=kG；
3、产生一个随机整数r（r<n），计算点R=rG；
4、将原数据和点R的坐标值x,y作为参数，计算SHA1做为hash，即Hash=SHA1(原数据,x,y)；
5、计算s≡r - Hash * k (mod n)
6、r和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行

验证过程如下：
1、接受方在收到消息(m)和签名值(r,s)后，进行以下运算
2、计算：sG+H(m)P=(x1,y1), r1≡ x1 mod p。
3、验证等式：r1 ≡ r mod p。
4、如果等式成立，接受签名，否则签名无效。

私钥本质上是一个随机数，由32个byte组成的数组，1个byte等于8位二进制，一个二进制只有两个值0或者1。所以私钥的总数是将近2^（8*32）=2^256个，但是有一些私钥并不能使用，他真实的大小是介于：1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141之间的数。这个数量已经超过了宇宙中原子的总数，想要遍历所有的私钥，耗尽整个太阳的能量也是不可能的。

1. 使用椭圆曲线加密算法计算上述私钥所对应的非压缩公钥

公钥：
5d036a858ce89f844491762eb89e2bfbd50a4a0a0da658e4b2628b25b117ae09

2. 对（压缩）公钥进行SHA-256哈希计算

3. 对步骤2的哈希值进行RIPEMD-160哈希计算

4. 使用Base58Check编码将结果从字节字符串转换为base58字符串。

5. 在步骤3的哈希值前添加前缀（比如：D)

与比特币比较，我们并没有添加`校验码`和`版本号`的过程，而是简化为独立标识的`D`等。未来，DDN 也将考虑使用校验码和版本号来生成新地址。

5. 对步骤4的扩展RIPEMD-160哈希值进行HA256哈希计算
6. 对步骤5的哈希值再次进行SHA256哈希计算
7. 取步骤6结果值的前4个字节作为
8. 将校验码添加到步骤4的扩展RIPEMD-160哈希值末尾

## 验证地址

1. 把地址base58解码成字节数组
2. 把数组分成两个字节数组，字节数组（1）是后4字节数组，字节数组（2）是减去后4字节的数组
3. 把字节数组（2）两次Sha256 Hash
4. 取字节数组（2）hash后的前4位，跟字节数组（1）比较。如果相同校验通过。
5. 校验通过的解码字节数组取第一个字节，地址前缀。
6. 检验前缀的合法性（根据主网参数校验），注意大小写。

